# Linux Commands

---

**What is a Shell?**
  - The shell is a command line interpreter that translates user commands into actions performed by the operating system
  - It displays output in the terminal and shows error messages when problems occur
  - The default shell in most Linux distributions is Bash (Bourne Again Shell)
  - The shell provides both an interactive interface and a powerful scripting language for automation

  - Functions are:
    - Command Interpretation and Execution
      - Examine user input commands to identify the program, its arguments, and I/O redirections.
    - System cell Invocation
      - Translates high level commands into low level kernel system calls (e.g., fork, exec).
    - Output and Error Handling
      - Captures and displays program output (stdout) and error messages (stderr).
    - Environment Management
      - Maintains environment variables (e.g., PATH) that define the shell's behavior and configuration.

**Linux Shell Prompt Format**

The command prompt format: 
    - Username: Current logged in user
    - Hostname: System name (check with `hostname` command)
    - Current Directory: 
      - `~` represents the user's home directory (typically `/home/username`)
      - `/` represents the root directory
      
- `username@hostname:current_directory$`
- Regular user: Ends with a dollar sign ($)
```
user@hostname:~$
```
<img width="797" height="165" alt="Screenshot 2025-12-04 at 6 46 01 AM" src="https://github.com/user-attachments/assets/b2860c3e-28b2-4e60-8d47-426271308364" />

- `username@hostname:current_directory#`
- Root user: Ends with a hash symbol (#)
```
root@hostname:~#
```
<img width="802" height="161" alt="Screenshot 2025-12-04 at 6 46 16 AM" src="https://github.com/user-attachments/assets/66a07525-779b-4029-904c-1305dc22b7bb" />
      
---

**Accessing the System**

**- Local Logins**
  - Physical console: Direct keyboard and display connection
  - Virtual consoles: Multiple independent login sessions accessible via Ctrl+Alt+F1 through Ctrl+Alt+F6
  - Graphical environment: Runs on one virtual console, with terminal applications providing shell access
  - Example:
    - Accessing Different Interfaces
```bash
Alt + Ctrl + F2 through F7             # Text based terminals (tty2-tty7)


Alt + Ctrl + F1 or F7                  # Graphical interface (typically)


tty                                    # Check current terminal
```

**- Virtual Console Allocation**
    - **tty1**: May be a graphical login screen (if GUI installed) on some modern distributions and display managers (e.g., Ubuntu + GDM), but on others, graphical sessions may use **tty7** or another tty.
    - **tty2-tty6**: Commonly used for text login prompts (getty), but actual assignment depends on distribution and system configuration.
  - Graphical sessions typically start on a virtual console (tty) chosen by the display manager or X/Wayland server, often tty1 or tty7, but this is configurable and varies between systems.


**- Remote Logins with SSH**
  - SSH Host Key Verification
    - On first connection, you'll see a host authenticity warning
    - Type yes to accept and save the host key for future connections
    - Host key mismatches on subsequent connections may indicate security issues
      
```bash
# Basic SSH connection
ssh username@remote_host
```
```bash
# Setting proper permissions for private key
chmod 600 identity_file.pem

# SSH with identity file (private key)
ssh -i identity_file.pem username@remote_host
```

---

**Switching Between Users**
```bash
su - username      # Switch to another user with their environment
exit               # Return to previous user
```

**Examples:**
```bash
su - root          # Switch to root user
su - cnode         # Switch to regular user
```
<img width="801" height="279" alt="Screenshot 2025-12-04 at 6 56 59 AM" src="https://github.com/user-attachments/assets/ebc6175a-9e67-4e98-a2e5-5b1470c6306f" />

>Note: Switching users doesn't log out the previous user; they remain hidden in the background.

**Superuser Access Methods**

| Feature | `su` | `su -` | `sudo` |
|---------|------|--------|--------|
| **User Change** | Yes | Yes | Per command |
| **Environment** | Current user's | New user's | Current user's |
| **Password** | Target user's | Target user's | Current user's |
| **Privileges** | Target user's | Target user's | Configured privileges |
| **Logging** | `su` command only | `su` command only | Each command logged |

---

**Logging Out**
  - Type `exit` or press Ctrl+D to end a shell session. For remote sessions, this closes the connection

---

**Adjusting Terminal Appearance**
```bash
Ctrl + Shift + +      # Increase font size
Ctrl + -              # Decrease font size
```

---

**Changing Own Password:**
```bash
passwd  
```

---

**What is a Linux Command?**
  - A Linux command is a text based instruction/program.
  - In Linux and other Unix like systems, a command typically invokes the execution of a specific program.
  - The shell interprets the command, locates the corresponding program, and requests the kernel to execute it, often resulting in a new process.

**Command Format**
```bash
command [options] [arguments]
```
  - **Command**: The program name to execute
  - **Options**: Modify command behavior (start with `-` or `--`)
  - **Arguments**: Targets for the command to operate on

**Characteristics**
  - Linux is case sensitive for commands, options, arguments, and filenames
  - Separate elements with spaces
  - Options can often be combined (order doesn't matter)*


**Command Types**

  - Shell Builtins
    - Commands implemented within the shell itself rather than as separate executables.
    - Provide essential functionality (e.g., environment manipulation) and execute with minimal overhead.
      
  - External Binaries
    - Standalone executable files located in filesystem directories referenced by the PATH variable.
    - Invoked only after aliases, functions, and builtins are considered.
      
  - Shell Functions
    - User or script defined blocks of shell code operate as named commands.
    - Enable modularization and abstraction within shell scripting.
      
  - Alias
    - User defined command substitutions that expand to longer command sequences.
    - Evaluated before all other command types in the shell’s resolution process.


- Command Resolution Order
  - Shells typically resolve commands in the following sequence:
    - Alias
    - Function
    - Builtin
    - External executable
Failure to locate a command results in a “command not found” error.

  - Performance Considerations
    - Builtins and functions avoid process creation overhead
    - External binaries incur fork-exec system call penalties
    - Aliases provide zero runtime cost textual substitution


**Internal and External Commands**

**Internal (Built-in) Commands:**
  - Part of the shell itself
  - No separate executable file
  - Loaded with shell, faster execution
  - Examples: `cd`, `type`, `echo`
```bash
type cd        # Shows cd is a shell builtin
type ls        # Shows ls is an alias (e.g., ls --color=auto)
type clear     # Shows clear is an external binary in /usr/bin
type useradd   # Shows useradd is an external binary in /usr/sbin
```

**External Commands:**
  - Separate executable files
  - Stored in directories listed in the `PATH` variable
  - Can be executed with full path
```bash
/bin/ls              # Execute using full path
which ls             # Find command location
which CLEAR          # Case sensitive search (fails)
which clear          # Correct case
which useradd        # Find system commands
```

<img width="664" height="413" alt="Screenshot 2025-11-30 at 12 21 24 PM" src="https://github.com/user-attachments/assets/7137fe8c-a39f-4f8a-9c5a-d1ed765c419f" />


---

**Escape Sequence**
  - Escape sequences in Linux are special character combinations used to represent non-printable characters, control terminal behavior, or format text.
  - Escape Sequence Prefixes:
    - \ (backslash) - Most common in shell/scripts
    - ^[ or \e or \033 or \x1b - For ANSI escape sequences
    - % - In printf format strings


| Character / Symbol | Purpose / When to Escape                                 | Example                     |                        |
| ------------------ | -------------------------------------------------------- | --------------------------- | ---------------------- |
| Space              | Include spaces in file names                             | `vi file\ name.txt`         |                        |
| `*`, `?`, `[`, `]` | Prevent wildcard expansion (globbing)                    | `rm special\*file`          |                        |
| `\`                | Escape a literal backslash                               | `mv file\\name newfile`     |                        |
| `$`                | Prevent variable expansion                               | `echo \$HOME`               |                        |
| `"`                | Prevent double quote interpretation inside double quotes | `echo \"Hello\"`            |                        |
| `'`                | Prevent single quote interpretation                      | `echo \'Hello\'`            |                        |
| `&`                | Prevent running in background                            | `echo hello \& goodbye`     |                        |
| `(` , `)`          | Prevent subshell interpretation                          | `echo \(test\)`             |                        |
| `{` , `}`          | Prevent brace expansion                                  | `echo file\{1,2\}`          |                        |
| `;`                | Prevent command separator                                | `echo hello\;world`         |                        |
| `                  | `                                                        | Prevent pipe interpretation | `echo hello \| grep h` |
| `<` , `>`          | Prevent input/output redirection                         | `echo hello \> file.txt`    |                        |
| `!`                | Prevent history expansion in some shells                 | `echo \!`                   |                        |
| `~`                | Prevent tilde expansion to home directory                | `echo \~user`               |                        |


---


**The Echo Command**
  - The echo command is one of the most basic and frequently used commands in Linux and Unix like operating systems. Its primary function is to display a line of text or to output the arguments it is given to the standard output (which is usually your terminal screen).
```bash
echo "Hello World"                                   # Basic text output
echo hello world                                     # Quotes optional for simple text
echo -e "Linux \bLearning \bStudent"                 # Interpret backslash escapes
echo -e "Name:\tJohn\nAge:\t30\nCity:\tNew York."
echo -e "This is line one.\nThis is line two."
```

Basic Backslash Escapes:
  - \b: Backspace (removes previous character)
  - \n: New line
  - \t: Tab
  - \a: Alert (Play a bell sound)
  - \v: Vertical Tab
  - \\	Print a literal backslash
  - \r	Carriage Return (Cursor moves to the start of the line)


---

**Fundamental Commands**

  - System Information
```bash
whoami        # Display current username
hostname      # Show system name
pwd           # Print working directory
date          # Show current date and time
timedatectl   # Detailed time and date information
cal           # Display calendar
cal 2024      # Show specific year calendar
cal 1 9999    # Calendar range: years 1-9999
clear         # Clear terminal screen
```

  - File Operation with ls
      Command Options and Arguments 
```bash
ls /etc                 # List /etc directory contents (argument)
ls -l                   # Long listing format (option)
ls -a                   # Show hidden files (option)
ls -r                   # Reverse order (option)
ls -lh                  # Human readable file sizes (combined options)
ls -l --human-readable  # Alternative format
ls -l -r                # Multiple options separately
ls -rl                  # Combined options (order doesn't matter)
ls -lr                  # Same as above
```

**Common Default Color Meanings:**
  - Check Your Current LS_COLORS
```bash
echo $LS_COLORS
```
  - While customizable, typical default color coding for ls includes:
    - Plain white/light gray = regular file (no special attributes)
    - Bold Blue: Directories
    - Bold Green: Executable files
    - Bold Cyan: Symbolic links
    - Bold Red: Archive files
    - Magenta: Image or video files
    - Yellow with Black Background: Pipes (FIFOs)
    - Red with Black Background: Orphaned symbolic links (pointing to a non existent file)
      
> If you want to customize: Add to ~/.bashrc or ~/.zshrc
  > Example: export LS_COLORS="di=01;35:ln=01;36:*.jpg=01;35:$LS_COLORS"


---


**Working with Multiple Commands**

**Command Separators:**
  - Semicolon (;) - Sequential Execution
    - Runs commands one after another, regardless of whether previous commands succeed or fail
    - It is used when you want all commands to execute unconditionally
      
  - Double Ampersand (&&) - Conditional Execution
    - Only runs the next command if the previous one succeeds (exit status 0)
    - It is used when subsequent commands depend on previous ones succeeding


```bash
date ; cal ; ls        # Execute sequentially regardless of success
date && cal && ls      # Execute only if previous command succeeds
```

**Error Handling Examples**
```bash
dat ; cal; ls          # 'dat' fails, but cal and ls still execute
dat && cal && ls       # 'dat' fails, so nothing else executes
```

**Command Grouping**

  - Without Grouping (only the last command redirected)
```bash
date; cal > datecaloutput
```

  - With grouping:
    - Both date 'AND' cal output are saved to outputofdatecal
    - Creates a subshell environment for the grouped commands 
```bash
(date; cal) > outputofdatecal      # Saves both commands' output
```

  - Saving to Specific Location
```bash
(date; cal) > Desktop/newfile   # Save to specific location
```

---


**File Management**

**Creating Files**
```bash
# Using cat (for quick creation)
cat > filename
Type your content
Ctrl+D to save

# Using text editors
vi filename      # Vim editor
nano filename    # Nano editor
gedit filename   # Graphical editor

# Create empty file or update timestamp
touch filename

# Create hidden file (starts with .)
touch .hiddenfile
```

**Text Editors:**
```bash
vi filename      # Press i to insert; type content, ESC then :wq to save, :q! to exit without saving

nano filename    # Nano editor; type content, Ctrl+X to exit, Y to save

gedit filename   # Graphical editor (like Notepad)
```

**Viewing File Content**
```bash
cat filename        # Display entire file
less filename       # Page through file (press Q to quit)
head filename       # Show first 10 lines
head -n 5 filename  # Show first 5 lines
tail filename       # Show last 10 lines
tail -n 5 filename  # Show last 5 lines
wc filename         # Count lines, words, characters
```


**File and Directory Space Usage**
```bash
# File size
ls -lh /etc/passwd

# Directory size
du -sh /etc
```

**File Metadata and Type Information**
```bash
# File metadata
stat /etc/passwd

# File type identification
file newimpfile.tar.gz
```


**File Operations**
```bash
# Rename or move files
mv oldname newname          # Rename or move a file
mv file1 file2 directory/   # Move multiple files to a directory

# mv options
mv -i file1 file2           # Prompt before overwrite
mv -f file1 file2           # Force overwrite


# Files with special characters
vi "file with spaces"           # File name with spaces (quoted)
vi file\ with\ spaces           # File name with spaces (escaped)
vi special\*file                # File name with literal asterisk
vi .redhat\ linux                # Hidden file name with space
vi file\ with\ spaces          # Spaces escaped

mv file\\name newfile          # Literal backslash
```

- MV Command's Behavior:
  - If the new name is an existing directory: MOVE operation
  - If the new name is not a directory: RENAME operation

---

**Exit Status**
  - Exit Status in Linux (also called exit code or return status) is a numerical value returned by a command or script to indicate whether it executed successfully or encountered an error.
    
  - Exit Status Values
    - 0: Success
    - 1–255: Error/failure (specific meanings vary by command)
      
  - Checking Command Success
```bash
echo $?    # Display exit status of last command, 0 = success, non zero = error
```

  - Common Exit Codes
    - 0: Success
    - 1: General error
    - 2: Misuse of shell builtins (e.g., cd with no arguments)
    - 126: Command invoked cannot execute
    - 127: Command not found
    - 128: Invalid argument to exit
    - 130: Script terminated by Ctrl+C (SIGINT)
    - 137: Process killed (SIGKILL)
    - 143: Process terminated (SIGTERM)

**Is exit status important?**
  - Yes, it plays a vital role in:
    - Automation: Scripts can decide subsequent actions based on success/failure.
    - Debugging: Identify where and why a failure occurred.
    - Pipeline Control: Chain commands conditionally.

---

**Comments**
```bash
# This is a comment; ignored by the shell

ls        # This command runs

# ls      # This is commented out
```

---

**Command History**
```bash
history           # Show command history
!number           # Execute command by number. e.g !45 execute command 45 from history
!!                # Execute most recent command
!string           # Execute most recent command starting with 'string' e.g. !c !l
Ctrl+R            # Search history interactively
!ls               # Execute last ls command
history 5               # Show last 5 commands
history | grep string   # Search history for specific commands
```

**History Navigation**
  - Up/Down arrows: Browse through history
  - Left/Right arrows: Move cursor for editing
  - Home/End: Jump to the beginning/end of the line
  - Ctrl+A: Jump to the beginning of the line
  - Ctrl+E: Jump to the end of the line
  - Ctrl+U: Clear from cursor to beginning
  - Ctrl+K: Clear from cursor to end
  - Alt+.: Insert the last word of the previous command

**Configuring History**
```bash
# Temporary changes (current session only)
HISTSIZE=100
echo $HISTSIZE

# Permanent changes for current user
# Edit ~/.bashrc and add:
HISTSIZE=2000
# Then reload: source ~/.bashrc

# System-wide changes (root only)
# Edit /etc/bashrc or /etc/profile
```

**History Files and Management:**
  - Current session: Commands are temporarily held in an in-memory buffer, allowing recall only within the current session.
  - Permanent storage: Commands are permanently recorded in ~/.bash_history, preserving historical data across sessions.
  - Each user has a separate history
  - After logout, buffer content appends to `.bash_history`
  - Default history size: 1000 commands (FIFO:First In First Out)

```bash
ls -a                    # Show hidden files including .bash_history
cat .bash_history        # View permanent command history
rm -f .bash_history      # Delete history file
```

---
**System Information**

**Memory Information**
```bash
free -h    # Human readable memory usage
```

**Understanding `free -h` output:**
```
               total   used   free   shared  buff/cache  available
Mem:           3.1Gi  1.1Gi  1.4Gi   33Mi       571Mi       1.7Gi
Swap:          2.0Gi   0B    2.0Gi
```

**Performance Implications:**
  - When available memory approaches zero, applications start using swap
  - Swap is much slower than RAM (runs on disk)
  - System slowdown complaints: check if applications are using swap
  - Solutions: Scale up RAM or terminate unnecessary applications

**CPU Information**
```bash
lscpu    # Detailed CPU architecture information
```

**Disk Information**
```bash
df -h        # Disk space usage (human-readable)
lsblk        # Block device information
```


**System Management: Date and Time Management**

```bash
# View current settings
date
timedatectl

# Change system time (root only)
sudo date --set="2025-01-15"        # Change date [yyyy-mm-dd]
sudo date --set="14:30:00"          # Change time [HH24:MI:SS]
```

**System Control**
```bash
# Shutdown options
shutdown --halt        # Stop OS but don't power off
shutdown --poweroff    # Power off system
poweroff               # Power off immediately

# Restart
reboot

# Scheduled shutdown
shutdown -h +30       # Shutdown in 30 minutes
shutdown -r 20:00     # Restart/reboot at 8 PM
```

---

**File System Comparison: Windows vs Linux**


| Windows | Linux | Purpose |
|---------|-------|---------|
| **FILE SYSTEM & DIRECTORIES** | | |
| `C:\Users\username` | `/home/username` | User home directory |
| `C:\` | `/` | Root directory |
| `C:\Program Files` | `/usr/bin`, `/opt` | Application installation |
| `C:\Windows\System32` | `/usr/bin`, `/sbin` | System binaries |
| `C:\Windows` | `/etc` | System configuration files |
| `C:\Temp` | `/tmp` | Temporary files |
| **BASIC COMMANDS** | | |
| `dir` | `ls` | List directory contents |
| `cd` | `cd` | Change directory |
| `mkdir` | `mkdir` | Create directory |
| `copy` | `cp` | Copy files |
| `move` | `mv` | Move files |
| `del` | `rm` | Delete files |
| `type` | `cat` | Display file content |
| `more` | `less` | View content page by page |
| `find` | `grep` | Search text in files |
| `fc` | `diff` | Compare files |
| `attrib` | `chmod` | Change file permissions |
| **SYSTEM INFORMATION** | | |
| `systeminfo` | `uname -a` | System information |
| `hostname` | `hostname` | Display computer name |
| `tasklist` | `ps`, `top` | List running processes |
| `taskkill` | `kill`, `pkill` | Terminate processes |
| `ipconfig` | `ifconfig`, `ip addr` | Network configuration |
| `ping` | `ping` | Network connectivity test |
| `netstat` | `netstat`, `ss` | Network statistics |
| `tracert` | `traceroute` | Network route tracing |
| **ADMINISTRATION** | | |
| `services.msc` | `systemctl` | Service management |
| `schtasks` | `cron`, `systemd timers` | Scheduled tasks |
| `regedit` | Configuration files in `/etc` | System configuration |
| **TEXT EDITORS** | | |
| `notepad` | `nano`, `vim` | Text editing |
| `wordpad` | `gedit`, `libreoffice` | Word processing |
| **MISCELLANEOUS** | | |
| `cls` | `clear` | Clear terminal screen |
| `echo` | `echo` | Display message |
| `set` | `env`, `printenv` | Environment variables |
| `help` | `man`, `--help` | Get command help |
| `mklink` | `ln -s` | Create symbolic links |
| Windows Store | `apt`, `yum`, `pacman` | Software installation |

---
