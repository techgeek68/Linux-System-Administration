# Standard Input, Output, Error, and Redirection

## Standard I/O Channels (File Descriptors)

Every running program (process) communicates through numbered channels called **file descriptors**. By default, a process has three standard channels:

| Number | Channel Name | Description | Default Connection | Usage |
|--------|--------------|-------------|-------------------|-------|
| 0 | **stdin** (Standard Input) | Receives input data | Keyboard | Read-only |
| 1 | **stdout** (Standard Output) | Sends normal program output | Terminal | Write-only |
| 2 | **stderr** (Standard Error) | Sends error messages and diagnostics | Terminal | Write-only |
| 3+ | *filename* | Additional files opened by the program | None | Read, write, or both |

**Note:** A process can open additional file descriptors (3, 4, 5, etc.) to interact with other files or network connections.

## Redirecting Output

I/O redirection changes where a process reads input or sends output. Instead of using the keyboard or terminal, data can be read from or written to files.

### Output Redirection Operators

| Operator | Explanation | Result |
|----------|-------------|--------|
| `> file` | Redirects **stdout** to a file (overwrites if file exists) | Creates new file or replaces existing content |
| `>> file` | Redirects **stdout** to a file (appends to end) | Preserves existing content, adds new output |
| `2> file` | Redirects **stderr** to a file (overwrites) | Saves error messages separately |
| `2>> file` | Redirects **stderr** to a file (appends) | Appends error messages to existing file |
| `> file 2>&1` | Redirects **both stdout and stderr** to same file | Combined output (overwrites) |
| `>> file 2>&1` | Redirects **both stdout and stderr** to same file (appends) | Combined output (appends) |
| `&> file` | **Bash shortcut** for `> file 2>&1` | Combined output (overwrites) |
| `&>> file` | **Bash shortcut** for `>> file 2>&1` (Bash 4+) | Combined output (appends) |
| `2> /dev/null` | Discards error messages completely | `/dev/null` is a special "black hole" device |

### Important Considerations

1. **Order matters** in redirection:
   ```bash
   # Correct: Redirect stdout to file, then redirect stderr to same location
   command > output.log 2>&1
   
   # Incorrect: This redirects stderr to current stdout (terminal), then stdout to file
   command 2>&1 > output.log  # Errors still go to terminal!
   ```

2. **Bash-specific operators** (`&>` and `&>>`) are convenient but not available in all shells. For portable scripts, use the explicit forms.

### Practical Examples

```bash
# Save current date to a file
date > /tmp/saved-timestamp

# Save last 100 lines of a log file
tail -n 100 /var/log/secure > /tmp/last-100-log-secure

# Combine multiple files
cat file1.txt file2.txt file3.txt > /tmp/combined-file

# Append to existing file
echo "New line of information" >> /tmp/many-lines-of-information

# Save find results and errors separately
find /etc -name passwd > /tmp/output.txt 2> /tmp/errors.txt

# Save find results, discard errors
find /etc -name passwd > /tmp/output.txt 2> /dev/null

# Save both output and errors together
find /etc -name passwd &> /tmp/all-output.txt
# OR (portable version)
find /etc -name passwd > /tmp/all-output.txt 2>&1

# Append both output and errors
find /etc -name passwd >> /tmp/all-output.txt 2>&1
```

## Redirecting Input

The `<` operator redirects **stdin** to read from a file instead of the keyboard:

```bash
# Count lines in a file (these are equivalent)
wc -l < filename.txt
cat filename.txt | wc -l
```

## Text Transformation with `tr`

The `tr` (translate) command converts or deletes characters. It reads from **stdin** and writes to **stdout**.

### Common Uses

```bash
# Convert lowercase to uppercase
tr 'a-z' 'A-Z' < input_file.txt

# Convert uppercase to lowercase
tr 'A-Z' 'a-z' < input_file.txt

# Save converted output to new file
tr 'a-z' 'A-Z' < input_file.txt > uppercase_file.txt

# Delete specific characters
tr -d ',' < data.csv  # Remove all commas

# Squeeze repeated characters
tr -s ' ' < file.txt  # Replace multiple spaces with single space
```

## Constructing Pipelines

A **pipeline** connects the stdout of one command to the stdin of another using the pipe character (`|`).

### Basic Pipeline Examples

```bash
# View long directory listings one page at a time
ls -l /usr/bin | less

# Count files in current directory
ls | wc -l

# List 10 most recently modified files
ls -t | head -n 10

# Complex pipeline: find, filter, sort, and count
find /var/log -name "*.log" | grep error | sort | uniq -c
```

### Pipelines vs. Redirection

- **Pipelines** pass data between commands
- **Redirection** sends data to/from files

**Important:** Redirection in the middle of a pipeline affects only that command:

```bash
# WRONG: Output goes to file, nothing passes to less
ls > /tmp/saved-output | less

# Use tee instead (see below)
```

## The `tee` Command

`tee` splits output: it sends stdin to both stdout (continuing the pipeline) AND to one or more files.

```bash
# View output AND save to file
ls -l | tee /tmp/saved-output | less

# Save to file without displaying
ls -l | tee /tmp/saved-output > /dev/null

# Append to file
ls -l | tee -a /tmp/appended-output

# Save to multiple files
ls -l | tee file1.txt file2.txt file3.txt

# Common pattern: Save intermediate results in pipeline
find /etc -type f | tee all_files.txt | grep conf | tee conf_files.txt | wc -l
```

## Redirecting stderr Through Pipelines

To include error messages in a pipeline, redirect stderr to stdout first:

```bash
# Correct way to pipe both stdout and stderr
find / -name "*.conf" 2>&1 | less

# Find configuration files, handling permission errors gracefully
find /etc -type f 2>&1 | grep -v "Permission denied" | head -20
```

**Note:** The merging operators (`&>` and `&>>`) don't work with pipes directly.

## Security Best Practices

1. **Avoid accidental overwrites:**
   ```bash
   # Set noclobber to prevent overwriting existing files
   set -o noclobber  # Now > will fail if file exists
   set +o noclobber  # Turn it off
   
   # Force overwrite when noclobber is set
   command >| file.txt
   ```

2. **Append-only files:** For critical logs, set the append-only attribute:
   ```bash
   chattr +a logfile.txt  # Requires root
   # File can only be appended to, not overwritten or deleted
   ```

3. **Always verify redirection targets** in scripts to avoid overwriting important files.

## Common Patterns and Tips

1. **Discard all output:**
   ```bash
   command > /dev/null 2>&1  # Silent execution
   ```

2. **Log everything with timestamp:**
   ```bash
   {
     echo "=== $(date) ==="
     command 2>&1
   } >> logfile.txt
   ```

3. **Debug scripts by logging stderr:**
   ```bash
   # In a script
   exec 2> /tmp/script-errors.log  # Redirect all subsequent stderr
   ```

4. **Create simple filters:**
   ```bash
   # Convert tabs to spaces
   cat file.txt | tr '\t' ' ' > spaced.txt
   
   # Extract specific columns
   cut -d: -f1,7 /etc/passwd | tr ':' '\t' > users-shells.txt
   ```

5. **Handle filenames with spaces:**
   ```bash
   # Always quote filenames in redirection
   command > "file with spaces.txt" 2> "error log.txt"
   ```

Remember: Redirection and pipes are fundamental to Unix/Linux system administration. Mastery of these concepts enables powerful command-line workflows and automation.
