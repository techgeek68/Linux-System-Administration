# Standard Input, Output, Error, and Redirection

A running program, or process, reads input and writes output. When you run a command from the shell prompt, it typically reads its input from the keyboard and sends its output to the terminal window.


**Standard I/O Channels (File Descriptors)**

 - Processes use numbered channels called file descriptors for I/O operations:

| Number | Channel | Description | Default | Access |
|--------|---------|-------------|---------|--------|
| 0 | stdin | Standard input | Keyboard | Read only |
| 1 | stdout | Standard output | Terminal | Write only |
| 2 | stderr | Standard error | Terminal | Write only |
| 3+ | filename | Other files | None | Read/Write |

> Note: A process can open additional file descriptors (3, 4, 5, etc.) to interact with other files or network connections.

**Diagram: Process I/O Channels**

```
┌──────────────────────────────────────┐
│                                      │
│  ┌────────────┐       ┌──────────┐   │
│  │  Keyboard  │──0──▶ │          │   │
│  └────────────┘       │          │   │
│                       │ PROCESS  │   │
│  ┌────────────┐       │          │   │
│  │  Terminal  │◀──1── │          │   │
│  │            │       │          │   │
│  │            │◀──2── │          │   │
│  └────────────┘       └──────────┘   │
│                                      │
│  stdin (0) = Standard Input          │
│  stdout (1) = Standard Output        │
│  stderr (2) = Standard Error         │
│                                      │
└──────────────────────────────────────┘
```

**Redirecting Output**

I/O redirection changes where a command reads its input or sends its output and errors, allowing data to come from or go to files instead of the terminal. Standard output can be saved to a file, which will be created if it doesn't exist or overwritten if it does. To discard output or errors entirely, they can be redirected to the special `/dev/null` file. This enables users to save messages for later review, suppress unnecessary information, or separate normal output from error messages.

**Output Redirection Operators**

| Operator | Explanation | Result |
|----------|-------------|--------|
| `> file` | Redirects stdout to a file (overwrites if file exists) | Creates new file or replaces existing content |
| `>> file` | Redirects stdout to a file (appends to end) | Preserves existing content, adds new output |
| `2> file` | Redirects stderr to a file (overwrites) | Saves error messages separately |
| `2>> file` | Redirects stderr to a file (appends) | Appends error messages to existing file |
| `> file 2>&1` | Redirects both stdout and stderr to same file | Combined output (overwrites) |
| `>> file 2>&1` | Redirects both stdout and stderr to same file (appends) | Combined output (appends) |
| `&> file` | Bash shortcut for `> file 2>&1` | Combined output (overwrites) |
| `&>> file` | Bash shortcut for `>> file 2>&1` (Bash 4+) | Combined output (appends) |
| `2> /dev/null` | Discards error messages completely | `/dev/null` is a special "black hole" device |

---

**Considerations**

1. Order matters in redirection:
   ```bash
   # Correct: Redirect stdout to file, then redirect stderr to the same location
   command > output.log 2>&1
   
   # Incorrect: This redirects stderr to current stdout (terminal), then stdout to file
   command 2>&1 > output.log  # Errors still go to terminal!
   ```

2. Bash specific operators (`&>` and `&>>`) are convenient but not available in all shells. For portable scripts, you can use the explicit forms.
   
---

**Examples**

   - Output Redirection
```bash
# Save timestamp
date > /tmp/saved-timestamp

# Copy last 100 lines
tail -n 100 /var/log/secure > /tmp/last-100-log-secure

# Concatenate multiple files
cat step1.sh step2.log step3 step4 > /tmp/all-four-steps-in-one

# List files (including hidden)
ls -a > my-file-names

# Append to existing file
echo "new line of information" >> /tmp/many-lines-of-information
```
   - Error Redirection
```bash
# Redirect errors only
find /etc -name passwd 2> /tmp/errors

# Separate output and errors
find /etc -name passwd > /tmp/output 2> /tmp/errors

# Discard errors
find /etc -name passwd > /tmp/output 2> /dev/null

# Combine output and errors (Method 1)
find /etc -name passwd &> /tmp/all-message-output

# Combine output and errors (Method 2 - POSIX compatible)
find /etc -name passwd > /tmp/output. log 2>&1

# Append both output and errors
find /etc -name passwd >> /tmp/all-message-output 2>&1
```

---

**Redirecting Input**

The `<` operator redirects stdin to read from a file instead of the keyboard:

```bash
# Count lines in a file (these are equivalent)
wc -l < filename.txt
cat filename.txt | wc -l
```

---

**Text Transformation with `tr`**

The `tr` (translate) command converts or deletes characters. It reads from **stdin** and writes to **stdout**.

**Uses**

```bash
# Convert lowercase to uppercase
tr 'a-z' 'A-Z' < input_file.txt

# Convert uppercase to lowercase
tr 'A-Z' 'a-z' < input_file.txt

# Save converted output to new file
tr 'a-z' 'A-Z' < input_file.txt > uppercase_file.txt

# Delete specific characters
tr -d ',' < data.csv  # Remove all commas

# Squeeze repeated characters
tr -s ' ' < file.txt  # Replace multiple spaces with single space
```

---

**Constructing Pipelines**

- A pipeline connects the stdout of one command to the stdin of another using the pipe character (`|`).
- Syntax: `command1 | command2 | command3`

**Process I/O Piping**
   - Connects the stdout of one command to the stdin of the next.
```
┌──────────────────────────────────────────────────────┐
│                                                      │
│  ┌──────────┐        ┌──────────┐        ┌────────┐  │
│  │          │        │          │        │        │  │
│  │ PROCESS  │──1──▶  │ PROCESS  │──1──▶  │Terminal│  │
│  │    1     │   |    │    2     │        │        │  │
│  │          │        │          │        │        │  │
│  └──────────┘        └──────────┘        └────────┘  │
│                                                      │
│  stdout of Process 1 → stdin of Process 2            │
│                                                      │
└──────────────────────────────────────────────────────┘
```
**Pipeline Examples**

```bash
# View long directory listings one page at a time
ls -l /usr/bin | less

# Count files in current directory
ls | wc -l

# List 10 most recently modified files
ls -t | head -n 10

# Complex pipeline: find, filter, sort, and count
find /var/log -name "*.log" | grep error | sort | uniq -c
```

---

**Pipelines vs. Redirection**

- Pipelines pass data between commands
- Redirection sends data to/from files

> Important: Redirection in the middle of a pipeline affects only that command:

```bash
# WRONG: Output goes to file, nothing passes to less
ls > /tmp/saved-output | less

# Use tee instead (see below)
```

---

**The `tee` Command**

- `tee` splits output: it sends stdin to both stdout (continuing the pipeline) AND to one or more files.
- Syntax: `command | tee FILE`

**Diagram: Process I/O Piping with tee**

```
┌────────────────────────────────────────────────────────┐
│                                                        │
│  ┌──────────┐    ┌─────────┐    ┌──────────┐           │
│  │          │    │         │    │          │           │
│  │ PROCESS  │─1─▶│   tee   │─1─▶│ PROCESS  │─1─▶ Terminal
│  │    1     │ |  │         │ |  │    2     │           │
│  │          │    │    │    │    │          │           │
│  └──────────┘    └────┼────┘    └──────────┘           │
│                       │                                │
│                       ▼                                │
│                   ┌────────┐                           │
│                   │  FILE  │                           │
│                   └────────┘                           │
│                                                        │
│tee splits output: one to file, one to the next process │
│                                                        │
└────────────────────────────────────────────────────────┘
```
  
```bash
# View output AND save to file
ls -l | tee /tmp/saved-output | less

# Save to file without displaying
ls -l | tee /tmp/saved-output > /dev/null

# Save final pipeline output to file
ls -t | head -n 10 | tee /tmp/ten-last-changed-files

# Append to file
ls -l | tee -a /tmp/appended-output

# Save to multiple files
ls -l | tee file1.txt file2.txt file3.txt

# Common pattern: Save intermediate results in pipeline
find /etc -type f | tee all_files.txt | grep conf | tee conf_files.txt | wc -l
```

---
**Redirection in the Middle of the Pipeline**
```bash
# WRONG: output goes to file, not to less
ls > /tmp/saved-output | less

# CORRECT: use tee to split output
ls | tee /tmp/saved-output | less
```

**Redirecting stderr Through Pipelines**

   - To include error messages in a pipeline, redirect stderr to stdout first:

```bash
# Correct way to pipe both stdout and stderr
find / -name "*.conf" 2>&1 | less

# Find configuration files, handling permission errors gracefully
find /etc -type f 2>&1 | grep -v "Permission denied" | head -20
```

> Note: The merging operators (`&>` and `&>>`) don't work with pipes directly.

---

**Things to remember**

1. **Avoid accidental overwrites:**
   ```bash
   # Set noclobber to prevent overwriting existing files
   set -o noclobber  # Now > will fail if file exists
   set +o noclobber  # Turn it off
   
   # Force overwrite when noclobber is set
   command >| file.txt
   ```

2. **Append only files:** For critical logs, set the append only attribute:
   ```bash
   chattr +a logfile.txt  # Requires root
   # File can only be appended to, not overwritten or deleted
   ```

3. **Always verify redirection targets** in scripts to avoid overwriting important files.
4. **Special File: /dev/null**
      - Purpose: Discard unwanted output (acts as a "black hole")
```bash
# Suppress error messages
find /etc -name passwd 2> /dev/null

# Suppress all output
command &> /dev/null
```
5. **Order Matters**
```bash
# CORRECT: Redirects both stdout and stderr to file
> output.log 2>&1

# INCORRECT: Only stdout goes to file, stderr to terminal
2>&1 > output. log
```
- `> output.log 2>&1`: First redirects stdout to file, then redirects stderr to where stdout is going (the file)
- `2>&1 > output.log`: First redirects stderr to where stdout currently is (terminal), then redirects stdout to a file

---
