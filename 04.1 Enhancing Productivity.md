**Enhancing Linux Productivity**

---

**Command line Editing Shortcuts**

| Shortcut | Description |
|----------|-------------|
| **CURSOR MOVEMENT** | |
| `Ctrl + A` | Jump to beginning of line |
| `Ctrl + E` | Jump to end of line |
| `Ctrl + B` | Move cursor back one character |
| `Ctrl + F` | Move cursor forward one character |
| `Alt + B` | Move cursor back one word |
| `Alt + F` | Move cursor forward one word |
| `Ctrl + Left Arrow` | Jump to previous word |
| `Ctrl + Right Arrow` | Jump to next word |
| **TEXT MANIPULATION** | |
| `Ctrl + U` | Clear from cursor to beginning of line |
| `Ctrl + K` | Clear from cursor to end of line |
| `Ctrl + W` | Delete word before cursor |
| `Alt + D` | Delete word after cursor |
| `Ctrl + Y` | Paste (yank) previously cut text |
| `Ctrl + _` | Undo last edit |
| `Ctrl + T` | Swap current character with previous |
| `Alt + T` | Swap current word with previous |
| `Alt + .` | Insert last word of previous command |
| `Alt + *` | Expand all wildcards |
| **HISTORY OPERATIONS** | |
| `Ctrl + R` | Search command history |
| `Ctrl + G` | Exit history search mode |
| `Ctrl + P` | Previous command in history |
| `Ctrl + N` | Next command in history |
| `Ctrl + S` | Forward search history |
| `Ctrl + O` | Execute command then show next |
| `!!` | Execute previous command |
| `!$` | Last word of previous command |
| **PROCESS CONTROL** | |
| `Ctrl + C` | Terminate current command |
| `Ctrl + Z` | Suspend current command |
| `Ctrl + D` | Exit shell (when line is empty) |
| `Ctrl + L` | Clear screen |
| `Ctrl + S` | Stop output to screen |
| `Ctrl + Q` | Resume output to screen |
| **COMPLETION** | |
| `Tab` | Auto-complete file/command name |
| `Tab Tab` | Show completion options |
| `Alt + ?` | Show possible completions |
| `Alt + *` | Insert all completions |
| `Alt + /` | Attempt filename completion |

*Note: Some shortcuts may vary between different shells (bash, zsh, fish) and terminal emulators.*


---


**TAB Completion**

- TAB completion is an essential productivity feature in Linux that automatically completes commands, filenames, directories, and other elements as you type.

- Uses of TAB Completion
  - **Command Name Completion**: Auto completes command names
  - **Directory and File Navigation**: Completes paths and filenames
  - **Variable and Environment Variable Completion**: Helps with scripting variables
  - **Package and Program Names**: Assists with package managers (yum/dnf)
  - **Username Completion**: Completes usernames in commands
  - **Options and Flags**: Helps complete command options
  - **Filename Completion**: Works even with spaces and special characters

**Characteristics:**
- Single TAB press; Auto completes if only one match exists
- Double TAB press; Shows all possible completions when multiple matches exist
- Not completion; When no matches are found
- Response to double TAB press:
  - Type `y` to see all possibilities
  - Type `n` to return to the command line
  - Press `q` to exit the possibilities list

**System File**
```bash
# Completion system architecture
/etc/bash_completion          # System-wide completion rules
~/.bash_completion           # User-specific completion rules
/usr/share/bash-completion/  # Completion script directory

# Completion types:
# - Command completion: `comm[TAB]` → `command`
# - File path completion: `/etc/pas[TAB]` → `/etc/passwd`
# - Variable completion: `$PA[TAB]` → `$PATH`
# - Hostname completion: `ssh server[TAB]` → `ssh server1.example.com`
```

**Examples:**
```bash
# Single match: completes automatically
  cd M[Tab]        # cd Music/

# Multiple matches: shows options
  cd P[Tab][Tab]   # Shows: Pictures/ Public/
  cd Pu[Tab]       # cd Public/
  cd Pi[Tab]       # cd Pictures/

# Command completion
  c[Tab][Tab]      # Shows all commands starting with 'c'
  cl[Tab]          # clear
  cle[Tab]         # clear
  clea[Tab]        # clear
```


---


**Multi line Command Processing**

  - Lexical Analysis:
    - Backslash (\) acts as a line continuation character
    - Escapes the immediate newline character (ASCII 10)
    - Must be the last character on the line (no trailing whitespace)
    - 

Syntax:
```bash
# Valid continuation
command arg1 arg2 \    # \ followed immediately by newline
    arg3 arg4

# Invalid - space after backslash breaks continuation
command arg1 arg2 \ [space]
    arg3 arg4          # Syntax error: command not found
```

---

**Heredoc**
  - A heredoc (here document) is a redirection method in Linux/Unix shells that allows you to pass multiple lines of input to a command or script.
  - Syntax
```bash
command << DELIMITER
line 1
line 2
...
DELIMITER
```

  - Rules for Heredoc Delimiters
    - Naming rules:
      - Must follow PHP label naming rules (alphanumeric + underscores)
      - Cannot start with a number
      - Typically uppercase by convention
    - Closing Delimiter Rules
      - Must be at the beginning of the line
      - Must be followed by a semicolon (with no spaces)
      - No indentation allowed (in standard heredoc)
  - Example:
```bash
// Correct
$text = <<<END
Some text
END;

// Incorrect - indented
$text = <<<END
Some text
    END;  // ERROR: Invalid
```
  - Delimiter Names:
```
<<<EOF      #End Of File
<<<EOD      #End Of Data
<<<END
<<<HTML
<<<SQL
<<<JS
<<<CONFIG
```

- Examples:
```bash
cat <<EOF
This is line 1
This is line 2
EOF
```
```bash
NAME="Alice"
cat <<EOF
Hello, $NAME
Today is $(date +%A).
EOF
```
  - Strip leading tabs with <<- (Note: only tabs are stripped; spaces are preserved.)
```bash
cat <<-EOF
	Line with a leading tab (tab will be removed)
	Another indented line
EOF
```
  - Create a file with heredoc
```bash
cat > myfile.txt <<EOF
Title: Example
Body: This file was created with a heredoc.
EOF
# then view it
cat myfile.txt
```
  - Write a file with elevated privileges using sudo + tee (Useful because sudo redirection itself wouldn't work in many shells)
```bash
sudo tee /etc/myapp.conf > /dev/null <<'CONF'
# config content here
setting1 = true
setting2 = "value"
CONF
```
  - Passing a script to a remote host via ssh
```bash
ssh user@remotehost 'bash -s' <<'SCRIPT'
echo "Running on $(hostname)"
# commands here run on remotehost
SCRIPT
```


---

**Wildcard Characters**

Wildcards are special characters used as placeholders to represent patterns in filenames and directories. They're commonly used with commands like `ls`, `cp`, `mv`, and `rm`.

**Basic Wildcards**

  - Asterisk (`*`) - Matches Zero or More Characters
```bash
ls *.txt            		  	# All files ending with .txt
cp source_dir/* dest_dir/  		# All files from source_dir
ls *.jpg              			# All JPEG files
ls file*.txt          			# Files starting with "file" and ending with .txt
```

  - Question Mark (`?`) - Matches Exactly One Character
```bash
ls file?.txt          			# File1.txt, fileA.txt, but NOT file10.txt
rm ???.txt            			# Remove files with exactly 3 characters before .txt
ls ?o??               			# 4-character names with 'o' as second character
```

**Advanced Wildcard Patterns**

  - Character Ranges (`[a-z]`)
```bash
ls -d [b-h]*          # Directories starting with b through h
ls -d *[b-h]          # Ending with b through h
ls -d *[b-h]?         # Second last character is b-h, last is any single char
```

  - Character Sets (`[abc]`)
```bash
ls -d [bh]*           # Starting with b OR h
ls -d [bpho]*         # Starting with b, p, h, or o
```

  - Exclusion Patterns (`[^ ]`)
```bash
ls -d [^b-h]*         # NOT starting with b through h
ls -d [^bh]*          # NOT starting with b OR h
```

**Examples**

```bash
cd /

# Directory-specific searches
ls -d ???             # 3-character directory names
ls -d b??             # 3-character names starting with 'b'
ls -d ??r             # 3-character names ending with 'r'

# Complex patterns
ls -d b*              # Anything starting with 'b'
ls -d *t              # Anything ending with 't'
ls -d *o?             # Second last character 'o', last character anything

cd
```

<img width="1003" height="379" alt="Screenshot 2025-12-01 at 12 06 15 PM" src="https://github.com/user-attachments/assets/7e2b7e6a-d0d2-4898-9be6-11b62f7d5167" />


**Note:**
- Shell expansion: Wildcards are expanded by the shell before command execution
- No matches: If no files match, the wildcard remains unchanged in the command
- Recursive operations: Use `-r` option with commands like `cp` and `mv` for subdirectories
- Caution: Always verify wildcard patterns with `ls` before using with `rm` or `mv`

---
