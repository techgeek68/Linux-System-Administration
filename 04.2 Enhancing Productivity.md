**Enhancing Linux Productivity**

---

**Linux command line interface (CLI) keyboard shortcuts**

| Shortcut | Description |
|----------|-------------|
| **CURSOR MOVEMENT** | |
| `Ctrl + A` | Jump to beginning of line |
| `Ctrl + E` | Jump to end of line |
| `Ctrl + B` | Move cursor back one character |
| `Ctrl + F` | Move cursor forward one character |
| `Alt + B` | Move cursor back one word |
| `Alt + F` | Move cursor forward one word |
| `Ctrl + Left Arrow` | Jump to previous word |
| `Ctrl + Right Arrow` | Jump to next word |
| **TEXT MANIPULATION** | |
| `Ctrl + U` | Clear from cursor to beginning of line |
| `Ctrl + K` | Clear from cursor to end of line |
| `Ctrl + W` | Delete word before cursor |
| `Alt + D` | Delete word after cursor |
| `Ctrl + Y` | Paste (yank) previously cut text |
| `Ctrl + _` | Undo last edit |
| `Ctrl + T` | Swap current character with previous |
| `Alt + T` | Swap current word with previous |
| `Alt + .` | Insert last word of previous command |
| `Alt + *` | Expand all wildcards |
| **HISTORY OPERATIONS** | |
| `Ctrl + R` | Search command history |
| `Ctrl + G` | Exit history search mode |
| `Ctrl + P` | Previous command in history |
| `Ctrl + N` | Next command in history |
| `Ctrl + S` | Forward search history |
| `Ctrl + O` | Execute command then show next |
| `!!` | Execute previous command |
| `!$` | Last word of previous command |
| **PROCESS CONTROL** | |
| `Ctrl + C` | Terminate current command |
| `Ctrl + Z` | Suspend current command |
| `Ctrl + D` | Exit shell (when line is empty) |
| `Ctrl + L` | Clear screen |
| `Ctrl + S` | Stop output to screen |
| `Ctrl + Q` | Resume output to screen |
| **COMPLETION** | |
| `Tab` | Auto-complete file/command name |
| `Tab Tab` | Show completion options |
| `Alt + ?` | Show possible completions |
| `Alt + *` | Insert all completions |
| `Alt + /` | Attempt filename completion |

> Note: Some shortcuts may vary between different shells (bash, zsh, fish) and terminal emulators.

**Advanced Shortcuts**
- `Ctrl + _` - Undo last edit
- `Alt + .` - Insert last argument of previous command
- `Ctrl + XX` - Move between the start of the line and the current position

**Bash-specific**
- `!!` - Repeat last command
- `!$` - Last argument of previous command
- `!*` - All arguments of the previous command
- `!n` - Execute command number `n` from history

---


**TAB Completion**

- TAB completion is an essential productivity feature in Linux that automatically completes commands, filenames, directories, and other elements as you type.

- Uses of TAB Completion
  - **Command Name Completion**: Auto completes command names
  - **Directory and File Navigation**: Completes paths and filenames
  - **Variable and Environment Variable Completion**: Helps with scripting variables
  - **Package and Program Names**: Assists with package managers (yum/dnf)
  - **Username Completion**: Completes usernames in commands
  - **Options and Flags**: Helps complete command options
  - **Filename Completion**: Works even with spaces and special characters

**Characteristics:**
- Single TAB press; Auto completes if only one match exists
- Double TAB press; Shows all possible completions when multiple matches exist
- Not completion; When no matches are found
- Response to double TAB press:
  - Type `y` to see all possibilities
  - Type `n` to return to the command line
  - Press `q` to exit the possibilities list

**System File**
```bash
# Completion system architecture
/etc/bash_completion          # System-wide completion rules
~/.bash_completion           # User-specific completion rules
/usr/share/bash-completion/  # Completion script directory

# Completion types:
# - Command completion: `comm[TAB]` → `command`
# - File path completion: `/etc/pas[TAB]` → `/etc/passwd`
# - Variable completion: `$PA[TAB]` → `$PATH`
# - Hostname completion: `ssh server[TAB]` → `ssh server1.example.com`
```

**Examples:**
```bash
# Single match: completes automatically
  cd M[Tab]        # cd Music/

# Multiple matches: shows options
  cd P[Tab][Tab]   # Shows: Pictures/ Public/
  cd Pu[Tab]       # cd Public/
  cd Pi[Tab]       # cd Pictures/

# Command completion
  c[Tab][Tab]      # Shows all commands starting with 'c'
  cl[Tab]          # clear
  cle[Tab]         # clear
  clea[Tab]        # clear
```


---


**Multi line Command Processing**

  - Lexical Analysis:
    - Backslash (\) acts as a line continuation character
    - Escapes the immediate newline character (ASCII 10)
    - Must be the last character on the line (no trailing whitespace)
    - 

Syntax:
```bash
# Valid continuation
command arg1 arg2 \    # \ followed immediately by newline
    arg3 arg4

# Invalid - space after backslash breaks continuation
command arg1 arg2 \ [space]
    arg3 arg4          # Syntax error: command not found
```

---

**Heredoc**
  - A heredoc (here document) is a redirection method in Linux/Unix shells that allows you to pass multiple lines of input to a command or script.
  - Syntax
```bash
command << DELIMITER
line 1
line 2
...
DELIMITER
```

  - Rules for Heredoc Delimiters
    - Naming rules:
      - Must follow PHP label naming rules (alphanumeric + underscores)
      - Cannot start with a number
      - Typically uppercase by convention
    - Closing Delimiter Rules
      - Must be at the beginning of the line
      - Must be followed by a semicolon (with no spaces)
      - No indentation allowed (in standard heredoc)
  - Example:
```bash
// Correct
$text = <<<END
Some text
END;

// Incorrect - indented
$text = <<<END
Some text
    END;  // ERROR: Invalid
```
  - Delimiter Names:
```
<<<EOF      #End Of File
<<<EOD      #End Of Data
<<<END
<<<HTML
<<<SQL
<<<JS
<<<CONFIG
```

- Examples:
```bash
cat <<EOF
This is line 1
This is line 2
EOF
```
```bash
NAME="Alice"
cat <<EOF
Hello, $NAME
Today is $(date +%A).
EOF
```
  - Strip leading tabs with <<- (Note: only tabs are stripped; spaces are preserved.)
```bash
cat <<-EOF
	Line with a leading tab (tab will be removed)
	Another indented line
EOF
```
  - Create a file with heredoc
```bash
cat > myfile.txt <<EOF
Title: Example
Body: This file was created with a heredoc.
EOF
# then view it
cat myfile.txt
```
  - Write a file with elevated privileges using sudo + tee (Useful because sudo redirection itself wouldn't work in many shells)
```bash
sudo tee /etc/myapp.conf > /dev/null <<'CONF'
# config content here
setting1 = true
setting2 = "value"
CONF
```
  - Passing a script to a remote host via ssh
```bash
ssh user@remotehost 'bash -s' <<'SCRIPT'
echo "Running on $(hostname)"
# commands here run on remotehost
SCRIPT
```


---

**Wildcard Characters**

Wildcards are special characters used as placeholders to represent patterns in filenames and directories. They're commonly used with commands like `ls`, `cp`, `mv`, and `rm`.

**Basic Wildcards**

  - Asterisk (`*`) - Matches Zero or More Characters
```bash
ls *.txt            		  	# All files ending with .txt
cp source_dir/* dest_dir/  		# All files from source_dir
ls *.jpg              			# All JPEG files
ls file*.txt          			# Files starting with "file" and ending with .txt
```

  - Question Mark (`?`) - Matches Exactly One Character
```bash
ls file?.txt          			# File1.txt, fileA.txt, but NOT file10.txt
rm ???.txt            			# Remove files with exactly 3 characters before .txt
ls ?o??               			# 4-character names with 'o' as second character
```

**Advanced Wildcard Patterns**

  - Character Ranges (`[a-z]`)
```bash
ls -d [b-h]*          # Directories starting with b through h
ls -d *[b-h]          # Ending with b through h
ls -d *[b-h]?         # Second last character is b-h, last is any single char
```

  - Character Sets (`[abc]`)
```bash
ls -d [bh]*           # Starting with b OR h
ls -d [bpho]*         # Starting with b, p, h, or o
```

  - Exclusion Patterns (`[^ ]`)
```bash
ls -d [^b-h]*         # NOT starting with b through h
ls -d [^bh]*          # NOT starting with b OR h
```

**Examples**

```bash
cd /

# Directory-specific searches
ls -d ???             # 3-character directory names
ls -d b??             # 3-character names starting with 'b'
ls -d ??r             # 3-character names ending with 'r'

# Complex patterns
ls -d b*              # Anything starting with 'b'
ls -d *t              # Anything ending with 't'
ls -d *o?             # Second last character 'o', last character anything

cd
```

<img width="760" height="398" alt="Screenshot 2025-12-01 at 12 19 22 PM" src="https://github.com/user-attachments/assets/b0fc83f7-099b-4fcd-aede-57ad08956ac8" />


**Note:**
- Shell expansion: Wildcards are expanded by the shell before command execution
- No matches: If no files match, the wildcard remains unchanged in the command
- Recursive operations: Use `-r` option with commands like `cp` and `mv` for subdirectories
- Caution: Always verify wildcard patterns with `ls` before using with `rm` or `mv`

---

## Aliases

  - Aliases are custom shortcuts for commands or command sequences.
  - They simplify the command line experience by making frequently used commands easier to remember and execute.
  - Aliases are defined in shell configuration files and are user specific by default.

> The most commonly used shell in Linux is the Bash shell (Bourne Again Shell). Aliases described in this document apply specifically to Bash, though similar concepts exist in other shells.

---

**1. Temporary Aliases**

Temporary aliases exist only for the current terminal session and are lost when the session ends.

Syntax:
```bash
alias alias_name='command'
```

Example:
```bash
alias ls='ls -l'
```
After creating this alias, typing `ls` executes `ls -l`.

<img width="802" height="391" alt="Screenshot 2025-12-07 at 8 20 23 AM" src="https://github.com/user-attachments/assets/128e3a25-96b3-4431-9d4c-2b56f971d331" />


**2. Permanent Aliases**

Permanent aliases persist across sessions by being stored in configuration files.

**For a Current User**

User specific aliases are stored in `~/.bashrc` (or `~/.bash_aliases` if it exists and is sourced by `.bashrc`).

1. Open your user's `.bashrc` file:
   ```bash
   vi ~/.bashrc
   ```
   (You can use any text editor like `nano` or `gedit`.)

2. Add alias definitions, typically at the end of the file:
   ```bash
   alias ls='ls -l'
   alias rm='rm -i'  # Prompts before removal
   ```

3. Save and exit the editor.

4. Apply changes immediately without logging out:
   ```bash
   source ~/.bashrc
   ```

**System Wide Aliases**

System wide aliases affect all users and are defined in `/etc/bashrc` (RHEL/CentOS/Fedora) or `/etc/bash.bashrc` (Debian/Ubuntu).


1. Switch to the root user or use `sudo`:
   ```bash
   su - root
   ```
   or
   ```bash
   sudo vi /etc/bashrc
   ```

2. Open the system configuration file:
   ```bash
   vi /etc/bashrc
   ```

3. Add alias definitions at the end of the file:
   ```bash
   alias c='clear'
   ```

4. Save and exit.

5. Apply changes:
   ```bash
   source /etc/bashrc
   ```

---

**Managing Aliases**

Viewing Existing Aliases

To list all aliases defined in the current session:
```bash
alias
```

Removing Aliases

To remove an alias from the current session:
```bash
unalias alias_name
```

Example:
```bash
unalias ls
```

To permanently remove an alias, delete or comment out its definition from the configuration file (`~/.bashrc` or `/etc/bashrc`) and reload the file.

---

**Considerations**:

  1. **Session Specificity**: Aliases are specific to the shell in which they're defined. Starting a new terminal session or switching to a different shell requires redefining aliases unless they're stored in appropriate configuration files.

  2. **Command Conflicts**: Choose alias names carefully to avoid overriding existing commands or system utilities. For example, avoid creating an alias named `ls` that changes its default behavior drastically.

  3. **Portability**: While aliases enhance personal workflow, relying heavily on custom aliases may reduce efficiency when working on systems where they aren't defined.

  4. **Limitations**: Aliases are best for simple command substitutions. For complex logic or scripting, consider using shell functions or scripts instead.

  5. **Alternative Locations**: Some distributions may use `~/.bash_aliases` for user specific aliases. This file is typically sourced from `~/.bashrc` if it exists.

---
