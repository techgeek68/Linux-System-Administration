# String Manipulation Tools in Linux/Unix

String manipulation tools are a set of command-line utilities that allow you to perform various operations on text data, such as: 
- Viewing
- Searching
- Filtering
- Transforming
- Processing text files
  
**Viewing File Contents**

`cat` - Concatenate and Display Files
  - The `cat` command displays the entire content of a file. It is best suited for small files.

- Syntax:
```bash
cat <filename>
```

- Example:
```bash
cat /etc/hosts
```

<img width="775" height="202" alt="Screenshot 2025-12-15 at 6 54 22 PM" src="https://github.com/user-attachments/assets/88d8881f-df2a-4817-a44e-d48d3ec10ca5" />

<img width="850" height="636" alt="Screenshot 2025-12-15 at 6 54 48 PM" src="https://github.com/user-attachments/assets/9cf798b1-d14a-455f-8eda-fb8530e00920" />


`less` - View Long Files Interactively
  - The `less` command displays file content one screen at a time, allowing both forward and backward navigation. It's ideal for viewing long files.

- Syntax:
```bash
less <filename>
```

- Example:
```bash
less /etc/passwd
```

  - Navigation in `less`:
    
| Key | Function |
|-----|----------|
| `/text` | Forward search |
| `?text` | Reverse search |
| `n` | Next occurrence (forward) |
| `N` | Next occurrence (reverse) |
| `G` | Move to bottom of file |
| `g` | Move to top of file |
| `q` | Exit from file |


**Viewing Partial File Contents**

`head` - Display First Lines
  - Displays the first few lines of a file (default: 10 lines).

- Syntax:
```bash
head -n <number> <filename>
# or
head -<number> <filename>
```

- Examples:
```bash
head /etc/passwd          # First 10 lines
head -n 5 /etc/passwd     # First 5 lines
head -5 /etc/passwd       # First 5 lines
```
<img width="842" height="245" alt="Screenshot 2025-12-15 at 6 57 53 PM" src="https://github.com/user-attachments/assets/7430d52f-aff1-47ae-84f7-3bb2c9ee7f97" />


`tail` - Display Last Lines
  - Displays the last few lines of a file (default: 10 lines).

- Syntax:
```bash
tail -n <number> <filename>
# or
tail -<number> <filename>
```

- Examples:
```bash
tail /etc/passwd          # Last 10 lines
tail -n 5 /etc/passwd     # Last 5 lines
tail -5 /etc/passwd       # Last 5 lines
```

<img width="850" height="243" alt="Screenshot 2025-12-15 at 6 58 40 PM" src="https://github.com/user-attachments/assets/15cd557d-8c98-4ff6-89e2-7377732c5965" />

---

**Counting File Elements**

 `wc` - Word Count
  - Counts lines, words, and characters in a file.

- Syntax:
```bash
wc [options] <filename>
```

- Options:
  
| Option | Description |
|--------|-------------|
| `-l` | Show total count of lines only |
| `-w` | Show total count of words only |
| `-c` | Show total count of characters only |

- Examples:
```bash
wc /etc/passwd            # Shows all counts lines, words, and characters

wc -l /etc/passwd         # Shows only line count
```

> Output format: `lines words characters filename`

---

**Sorting File Content**
  - Display content of a file in sorted (ordered) form

- Syntax:
```bash
sort [options] <filename>
```

- Common Options:
  
| Option | Description |
|--------|-------------|
| `-n` | Numeric sort |
| `-k <position>` | Specify position/field to sort |
| `-r` | Reverse sorting |
| `-t <separator>` | Specify field separator |


- Examples:
```bash
# Alphabetical sort (default)
sort /etc/passwd

# Numeric sort on 3rd field (UID) with :  separator
sort -n -k 3 -t : /etc/passwd

# Reverse numeric sort on 3rd field
sort -n -k 3 -t :  -r /etc/passwd
```

---

**Extracting Specific Content**

`cut` - Cut Out Sections
  - Extracts specific columns or characters from each line of a file.

- Syntax:
```bash
cut [options] <filename>
```

- Options:
  
| Option | Description |
|--------|-------------|
| `-f <field_no>` | Specify field number to display |
| `-d <delimiter>` | Specify field separator |
| `-c <char_no>` | Show only specific characters |

- Examples:
```bash
# Extract usernames (1st field) from /etc/passwd
cut -f 1 -d : /etc/passwd

# Display multiple fields (username, UID, home, shell)
cut -f 1,3,6,7 -d : /etc/passwd

# Display range of fields (1-4)
cut -f 1-4 -d : /etc/passwd
or
cut -f 4- -d : /etc/passwd

# Display from field 4 to end of line
cut -f 4- -d : /etc/passwd

# Save output to file
cut -f 1,3,6,7 -d : /etc/passwd > passwd_selectedinfo
```

- Character Based Examples
  - Sample File (testfile):
```
This is first line.
This is second line.
This is third line. 
```

- Examples:
```bash
# Cut first 3 characters
cut -c 1-3 testfile

# Cut from 6th character to end
cut -c 6- testfile
```

---

**Using Pipelines**

- A pipeline connects commands so that the output of one command is used as input for the next command.
- Diagram

```
┌────────────────────────────────────────────────────────┐
│                                                        │
│  cmd1 ──output──▶ | ──▶ cmd2 ──output──▶ | ──▶ cmd3    │
│                                                        │
│  Output becomes input for next command                 │
│                                                        │
└────────────────────────────────────────────────────────┘
```

- Examples:
```bash
# Extract usernames and sort them
cut -f 1 -d :  /etc/passwd | sort

# Extract usernames, sort, and view with less
cut -f 1 -d : /etc/passwd | sort | less

# Count lines in passwd file
cat /etc/passwd | wc -l
```

---

**Finding Unique Lines**

`uniq` - Report or Filter Repeated Lines
  - Filters adjacent duplicate lines from sorted input.

> `uniq` only removes consecutive duplicate lines, so sorting is usually required first.

- Syntax:
```bash
uniq [options] <input>
```

Common Option:
- `-c`: Count occurrences of each line

- Examples:
```bash
# First sort, then find unique lines
cut -f 1 -d : /etc/passwd | sort | uniq

# Count unique occurrences
cut -f 1 -d : /etc/passwd | sort | uniq -c

# Display unique shells (WRONG - won't work properly)
cut -f 7 -d : /etc/passwd | uniq

# Display unique shells (CORRECT - with sort)
cut -f 7 -d : /etc/passwd | sort | uniq

# Display unique shells with count
cut -f 7 -d : /etc/passwd | sort | uniq -c
```

---

**Capturing Pipeline Output**
  - Store intermediate results of a pipeline without blocking the flow
    
`tee` - Redirect to Multiple Destinations
  - Reads from standard input and writes to both standard output and files.

- Syntax:
```bash
command1 | tee file1 | command2 | tee file2 | command3
```

- Diagram:  Pipeline with tee

```
┌───────────────────────────────────────────────────────┐
│                                                       │
│  cmd1 ──▶ tee ──▶ cmd2 ──▶ tee ──▶ cmd3               │
│             │                 │                       │
│             ▼                 ▼                       │
│          file1             file2                      │
│                                                       │
│  Data flows through pipeline AND saves to files       │
│                                                       │
└───────────────────────────────────────────────────────┘
```

- Example:
```bash
# Save intermediate outputs
cut -f 1 -d : /etc/passwd | tee cutoutput | sort | tee sortoutput | uniq -c | tee uniqout

# View saved files
ls
cat cutoutput

# Alternative (saves final output with redirection)
cut -f 1 -d : /etc/passwd | tee cutoutput | sort | tee sortoutput | uniq -c > uniqout
```

> Note: Using redirection operator (`>`) in the middle of a pipeline breaks the flow.  Use `tee` instead.

---

**Pattern Matching**
  - Search for a given pattern in a file and display all matching lines

`grep` - Global Regular Expression Print
  - Searches for patterns in files and displays matching lines.

- Syntax:
```bash
grep [option] <pattern> <filename>
```

- Options:
  - `-v`: Invert match (show non matching lines)
  - `-c`: Count matching lines only
  - `-r` or `-R`: Recursive search in directories
  - `-i`: Case insensitive search
  - `-n`: Show line numbers
  - `-E`: Extended regular expressions (same as `egrep`)
  - Special Characters:
    - `^pattern`: Lines beginning with pattern
    - `pattern$`: Lines ending with pattern
    - `\.`: Escape special characters (e.g., `\.` for literal dot)

- Examples:
```bash
# Search for user in passwd file
grep david /etc/passwd
grep dav /etc/passwd
grep da /etc/passwd
grep root /etc/passwd

# Find bash shell users
grep bash /etc/passwd

# Find bash shell usernames only
grep bash /etc/passwd | cut -f 1 -d : 

# Sort bash shell users alphabetically
grep bash /etc/passwd | cut -f 1 -d : | sort

# Count bash shell users
grep -c bash /etc/passwd

# Find users NOT using bash shell
grep -v bash /etc/passwd
grep -vc bash /etc/passwd  # Count only

# Lines beginning with 'root'
grep ^root /etc/passwd
grep ^s /etc/passwd

# Lines beginning with '#' (comments)
grep ^# /etc/bashrc
grep -v ^# /etc/bashrc  # Non-commented lines

# Search for '#' anywhere (escape special character)
grep \# /etc/bashrc

# Non-commented lines with count
grep -v \# /etc/bashrc | wc -l

# Recursive search for 'bash' in home directory
grep -r bash ~

# Lines ending with 'login'
grep login$ /etc/passwd
grep n$ /etc/passwd

# Case-insensitive search
grep -i ava /etc/passwd
```

- `egrep` - Extended Grep
  - Supports extended regular expressions (same as `grep -E`).
  - Grep with extended regular expressions (supports OR, AND operations)

- Operators

| Operator | Function |
|----------|----------|
| `|` | OR |
| `.*` | AND (any characters between) |



**Examples:**
```bash
# Create backup
cp /etc/passwd database

# Search for lines containing 'bash' OR 'login'
egrep 'bash|login' database

# Search for lines containing 'no' AND 'login' with any characters between
egrep 'no.*login' database
```

---

**Comparing Files**

`diff` - Compare Files Line by Line
  - Shows differences between two files.

- Syntax:
```bash
diff <file1> <file2>
```

Output Format:
  - Lines prefixed with `<` are from the first file
  - Lines prefixed with `>` are from the second file
  - Line numbers indicate where changes occur

- Examples
```bash
# Create two similar files with slight differences
echo "This is the first line." > file1
echo "This is the frist line." > file2
diff file1 file2
```
```bash
# Create backup and add user
cp /etc/passwd database
useradd pythondev
cp /etc/passwd database1

# Compare files
diff database database1

# Output: 
# 51a52
# > pythondev:x:1001:1001::/home/pythondev:/bin/sh
# 51 → first file line number
# 52 → second file line number
```

- diff Output Symbols

| Symbol | Meaning |
|--------|---------|
| `a` | Added |
| `c` | Changed |
| `d` | Deleted |
| `<` | Line from first file |
| `>` | Line from second file |

---

**Stream Editor (`sed`) Command**

`sed` - Stream Editor
  - Performs text transformations on an input stream.

Syntax:
```bash
sed 's/pattern/replacement/flags' <filename>
```

Multiple replacements:
```bash
sed -e 's/current_text/new_text/g' -e 's/current_text_1/new_text_1/g' filename
```

> Note: `sed` does not modify the source file; it only prints changes to terminal.  Save output using redirection.

- Common Flags:
  - `g`: Replace all occurrences (global)
  - `i`: Case insensitive matching

- Examples:
```bash
# Create backup file
cp /etc/passwd database

# Replace 'nologin' with 'yeslogin'
sed 's/nologin/yeslogin/g' database

# Save changes to a new file
sed 's/nologin/yeslogin/g' database > newdatabase

# Multiple replacements
sed -e 's/nologin/YESLOGIN/g' -e 's/bash/zsh/g' database > multiple_changes
```

> Note: By default, `sed` outputs to stdout without modifying the original file.

---

**Pattern Scanning and Processing**

`awk` - Text Processing Language
  - Processes and analyzes text files, particularly structured data.
  - Display specific columns of a file in the desired format
  - Default separator is space

- Syntax:
```bash
awk '{print $<field_number> "<separator>" $<field_number> ... }' filename
```

- Common Usage:
  - `$1`, `$2`, ...: Represent fields in the current line
  - `NF`: Number of fields in current line
  - `NR`: Current line number
  - `FS`: Field separator (default: whitespace)
  - `OFS`: Output field separator (default: space)

- Examples
```bash
# Create a sample file
echo "echo hello world!" > helloworld

# Print specific fields with custom separator
awk '{print $1 ";" $2 ";" $3}' helloworld

# Reorder fields
awk '{print $3 ";" $2 ";" $1}' helloworld

# Specify input field separator
awk -F: '{print $1, $3}' /etc/passwd

# Conditional processing
awk -F: '$3 > 1000 {print $1}' /etc/passwd

# Without spaces in the separator
awk '{print $3";"$2";"$1}' helloworld
```

> Note: By default, `awk` uses whitespace as the field separator. Use `-F` to specify a different separator.

---

