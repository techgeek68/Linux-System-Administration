# Linux Basic Commands

---

**User Accounts and Login**


**Root vs Normal User**

**Root User:**
  - Username: `root`
  - Command prompt ends with `#`
  - Has full administrative privileges
  - Can perform system wide changes

**Normal User:**
  - Username: custom name
  - Command prompt ends with `$`
  - Limited privileges
  - Can only modify own files and settings


**Understanding the Command Prompt**

The command prompt format: `username@hostname:current_directory$`

**Components:**
  - **Username**: Current logged in user
  - **Hostname**: System name (check with `hostname` command)
  - **Current Directory**: 
    - `~` represents user's home directory (typically `/home/username`)
    - `/` represents root directory

---

**Terminal Basics**

**Adjusting Terminal Appearance**
```bash
Ctrl + Shift + +      # Increase font size
Ctrl + -              # Decrease font size
```

---

**User Management**

**Creating Users and Setting Passwords:**
```bash
useradd username    # Create new user (root only)
passwd username     # Set password for user
```

**Examples:**
```bash
useradd natasha     # Create user natasha
passwd tom          # Set password for user tom
```

**Password Guidelines:**
  - Minimum 8 characters
  - Not similar to username
  - Avoid dictionary words
  - Include uppercase, lowercase, numbers, and special characters

**Notes:**
  - Root user can set weak passwords (with a warning)
  - Normal users cannot add other users
  - Normal users can only change their own password

**Changing Own Password:**
```bash
passwd              # Change current user's password
```

---

**User Switching and Privileges**

**Switching Between Users**
```bash
su - username      # Switch to another user with their environment
exit               # Return to previous user
```

**Examples:**
```bash
su - root          # Switch to root user
su - username      # Switch to regular user
```

**Note:** Switching users doesn't log out the previous user - they remain hidden in the background.

**Superuser Access Methods**

| Feature | `su` | `su -` | `sudo` |
|---------|------|--------|--------|
| **User Change** | Yes | Yes | Per command |
| **Environment** | Current user's | New user's | Current user's |
| **Password** | Target user's | Target user's | Current user's |
| **Privileges** | Target user's | Target user's | Configured privileges |
| **Logging** | `su` command only | `su` command only | Each command logged |

---

**Understanding Linux Commands and Shell**

**What is a Shell?**
  - It's a command line interpreter
  - A primary user interface for interaction with an operating system's kernel.
  - Functions are
    - Command Interpretation and Execution
      - Examine user input commands to identify the program, its arguments, and I/O redirections.
    - System cell Invocation
      - Translates high level commands into low level kernel system calls (e.g., fork, exec).
    - Output and Error Handling
      - Captures and displays program output (stdout) and error messages (stderr).
    - Environment Management
      - Maintains environment variables (e.g., PATH) that define the shell's behavior and configuration.

**What is a Linux Command?**
  - A Linux command is a text based instruction/program.
  - In Linux and other Unix like systems, a command typically invokes the execution of a specific program.
  - The shell interprets the command, locates the corresponding program, and requests the kernel to execute it, often resulting in a new process.

**Command Structure**
```bash
command [options] [arguments]
```

**Components:**
  - **Command**: The program name
  - **Options**: Modify command behavior (start with `-` or `--`)
  - **Arguments**: Additional information (filenames, directories, etc.)

**Important Notes:**
  - Linux is case sensitive
  - Options and arguments are space-separated
  - Multiple options can often be combined


**Basic Commands**
```bash
ls            # List directory contents
date          # Show current date and time
cal           # Display calendar
cal 2024      # Show specific year calendar
cal 1 9999    # Calendar range: years 1-9999
clear         # Clear terminal screen
```

**Common Default Color Meanings:**
  - Check Your Current LS_COLORS
```bash
echo $LS_COLORS
```
  - While customizable, typical default color coding for ls includes:
    - Plain white/light gray = regular file (no special attributes)
    - Bold Blue: Directories
    - Bold Green: Executable files
    - Bold Cyan: Symbolic links
    - Bold Red: Archive files
    - Magenta: Image or video files
    - Yellow with Black Background: Pipes (FIFOs)
    - Red with Black Background: Orphaned symbolic links (pointing to a non existent file)
      
> If you want to customize: Add to ~/.bashrc or ~/.zshrc
  > Example: export LS_COLORS="di=01;35:ln=01;36:*.jpg=01;35:$LS_COLORS"

**Command Options and Arguments**
```bash
ls /etc                 # List /etc directory contents (argument)
ls -l                   # Long listing format (option)
ls -a                   # Show hidden files (option)
ls -r                   # Reverse order (option)
ls -lh                  # Human readable file sizes (combined options)
ls -l --human-readable  # Alternative format
ls -l -r                # Multiple options separately
ls -rl                  # Combined options (order doesn't matter)
ls -lr                  # Same as above
```

---

**Advanced Command Execution**

**Command Separators: Executing Multiple Commands**
  - Semicolon (;) - Sequential Execution
    - Behavior: Runs commands one after another, regardless of whether previous commands succeed or fail
    - Use case: When you want all commands to execute unconditionally
      
  - Double Ampersand (&&) - Conditional Execution
    - Behavior: Only runs the next command if the previous one succeeds (exit status 0)
    - Use case: When subsequent commands depend on previous ones succeeding


```bash
date ; cal ; ls        # Execute sequentially regardless of success
date && cal && ls      # Execute only if previous command succeeds
```

**Error Handling Examples**
```bash
dat ; cal; ls          # 'dat' fails, but cal and ls still execute
dat && cal && ls       # 'dat' fails, so nothing else executes
```

**Command Grouping**

  - Without Grouping (only the last command redirected)
```bash
date; cal > datecaloutput          # Only saves cal output (last command)
```

  - With grouping:
    - Both date 'AND' cal output are saved to outputofdatecal
    - Creates a subshell environment for the grouped commands 
```bash
(date; cal) > outputofdatecal      # Saves both commands' output
```

  - Saving to Specific Location
```bash
(date; cal) > Desktop/newfile   # Save to specific location
```

---

**The Echo Command**
  - The echo command is one of the most basic and frequently used commands in Linux and Unix like operating systems. Its primary function is to display a line of text or to output the arguments it is given to the standard output (which is usually your terminal screen).
```bash
echo "Hello World"                                   # Basic text output
echo hello world                                     # Quotes optional for simple text
echo -e "Linux \bLearning \bStudent"                 # Interpret backslash escapes
echo -e "Name:\tJohn\nAge:\t30\nCity:\tNew York"
echo -e "This is line one.\nThis is line two."
```

Basic Backslash Escapes:
  - \b: Backspace (removes previous character)
  - \n: New line
  - \t: Tab
  - \a: Alert (Play a bell sound)
  - \v: Vertical Tab
  - \\	Print a literal backslash
  - \r	Carriage Return (Cursor moves to the start of the line)

---

**Command Types**

  - Shell Builtins
    - Commands implemented within the shell itself rather than as separate executables.
    - Provide essential functionality (e.g., environment manipulation) and execute with minimal overhead.
  - External Binaries
    - Standalone executable files located in filesystem directories referenced by the PATH variable.
    - Invoked only after aliases, functions, and builtins are considered.
  - Shell Functions
    - User or script defined blocks of shell code operate as named commands.
    - Enable modularization and abstraction within shell scripting.
  - Alias
    - User defined command substitutions that expand to longer command sequences.
    - Evaluated before all other command types in the shell’s resolution process.


- Command Resolution Order
  - Shells typically resolve commands in the following sequence:
    - Alias
    - Function
    - Builtin
    - External executable
Failure to locate a command results in a “command not found” error.

  - Performance Considerations
    - Builtins and functions avoid process creation overhead
    - External binaries incur fork-exec system call penalties
    - Aliases provide zero runtime cost textual substitution

**Internal and External Commands**

**Internal (Built-in) Commands:**
  - Part of the shell itself
  - No separate executable file
  - Loaded with shell, faster execution
  - Examples: `cd`, `type`, `echo`
```bash
type cd        # Shows cd is a shell builtin
type ls        # Shows ls is an alias (e.g., ls --color=auto)
type clear     # Shows clear is an external binary in /usr/bin
type useradd   # Shows useradd is an external binary in /usr/sbin
```

**External Commands:**
  - Separate executable files
  - Stored in directories listed in `PATH` variable
  - Can be executed with full path
```bash
/bin/ls              # Execute using full path
which ls             # Find command location
which CLEAR          # Case sensitive search (fails)
which clear          # Correct case
which useradd        # Find system commands
```

<img width="664" height="413" alt="Screenshot 2025-11-30 at 12 21 24 PM" src="https://github.com/user-attachments/assets/7137fe8c-a39f-4f8a-9c5a-d1ed765c419f" />

--

**File Operations**

**Creating Files**

**Using cat:**
```bash
cat > file1
This is file1.
Ctrl+D              # Save and exit
```

**Using Text Editors:**
```bash
vi filename      # Vi editor 
# Press i to insert, type content, ESC then :wq to save, :q! to exit without saving

nano filename    # Nano editor - type content, Ctrl+X to exit, Y to save

gedit filename   # Graphical editor (like Notepad)
```

**Creating Empty Files:**
```bash
touch filename    # Create empty file or update timestamp
touch file1 file3 # Create multiple files
```

### File Management
```bash
cat filename          # View file content
mv old new            # Rename file
mv file dir/          # Move file to directory
mv -i file new        # Interactive rename (prompt before overwrite)
mv -f file new        # Force rename (no prompt)
```

**MV Command Behavior:**
- If new name is existing directory → MOVE operation
- If new name is not a directory → RENAME operation

### Special Filenames
```bash
vi "new file"              # Using quotes for spaces
vi .redhat\linux           # Using backslash escape
vi Red\ Hat\ Certification # Multiple spaces
vi .redhat\ linux          # Hidden file with space
```

**Escape Character:** `\` kills the special meaning of the next character

### Hidden Files
```bash
mkdir .newfile      # Create hidden directory
ls                  # Regular listing - hidden files not shown
ls -a               # Show all files including hidden
cat .newfile        # Access hidden file
```

**Rule:** Any file/directory starting with `.` is hidden

## System Information and Control

### Date and Time
```bash
date                    # Current date and time
timedatectl             # Detailed time information
```

**Changing Date/Time (Root only):**
```bash
su - root
date --set=2025-01-15   # Change date [yyyy-mm-dd]
date --set=14:30:00     # Change time [HH24:MI:SS]
```

### Exit Status Checking
```bash
echo $?    # Check exit status of last command
```
- `0` = Success
- Non-zero = Error

### Comments
```bash
# This is a comment
ls        # This command will execute
#ls       # This is commented out
```

## Command History

### History Basics
```bash
history          # Show command history
↑ / ↓            # Navigate through history
!!               # Execute last command
!ls              # Execute last ls command
!45              # Execute command #45 from history
```

**Additional History Features:**
```bash
history 5               # Show last 5 commands
history | grep string   # Search history for specific commands
!1-3                   # Execute commands 1 through 3 from history
```

### History Configuration

**Temporary Changes:**
```bash
HISTSIZE=100     # Set history size for current session
echo $HISTSIZE   # Check current history size
HISTSIZE=0       # Disable history for current session
```

**Note:** Even with HISTSIZE=0, commands are still saved to `.bash_history` file

**Permanent Changes:**

*For current user:*
```bash
vim ~/.bashrc
# Add: HISTSIZE=2000
source ~/.bashrc    # or: . ~/.bashrc
```

*System-wide (root only):*
```bash
vim /etc/bashrc     # or: vim /etc/profile
# Add: HISTSIZE=400
source /etc/bashrc
```

**Note:** User-specific `.bashrc` settings override system-wide settings

### History Files and Management
```bash
ls -a                    # Show hidden files including .bash_history
cat .bash_history        # View permanent command history
rm -f .bash_history      # Delete history file
```

**How History Works:**
- Current session: Stored in memory buffer
- Permanent storage: Saved to `~/.bash_history` file
- Each user has separate history
- After logout, buffer content appends to `.bash_history`
- Default history size: 1000 commands (FIFO - First In First Out)

## System Power Control

### Shutdown and Restart
```bash
shutdown --halt        # Stop operating system
shutdown --poweroff    # Power off system
poweroff               # Immediate power off
reboot                 # Restart system
```

## Directory Navigation and Comparison

### Working with Directories
```bash
whoami                 # Show current username
pwd                    # Show current working directory path
```

### Windows vs Linux Path Comparison
```
Windows: C:\Users\user_name   =   Linux: /home/user_name
Windows: C:\ (root)           =   Linux: / (root directory)
```

## Practical Tips and Verification

### Command Verification
```bash
type command    # Check command type (internal/external)
which command   # Find command location
echo $?         # Verify last command success
```

### File Operations Best Practices
- Use `-i` option with `mv` for safety (default for root)
- Use `-f` option to force overwrite (default for normal users)
- Hidden files start with `.` (use `ls -a` to view)
- Escape spaces in filenames with `\` or use quotes

### History Management
- Regular users can only modify their own history settings
- Root can set system-wide defaults
- History persists in `.bash_history` between sessions
- Deleting `.bash_history` removes permanent record (temporary until next login)

This comprehensive guide covers all commands, examples, and concepts from your three PDF files, including user management, file operations, command history, system control, and practical Linux usage scenarios.
