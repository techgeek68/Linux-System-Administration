## Managing Files and Directories Through Command 

The primary commands discussed are `mv` (move/rename), `cp` (copy), and `rm` (remove/delete).

---

**Moving and Renaming Files and Directories**

- The `mv` Command

The `mv` command moves files and directories within the filesystem. It can also rename items by moving them to a new name in the same location.

- Basic Syntax
```bash
mv [options] <source> <destination>
```

| Option | Description                                                                      |
| ------ | -------------------------------------------------------------------------------- |
| -i     | Interactive; prompt before overwriting an existing file                          |
| -f     | Force; overwrite without prompting                                               |
| -n     | No clobber; do not overwrite existing files                                      |
| -v     | Verbose; show files as they are moved                                            |
| -u     | Update; move only if source is newer than destination or destination is missing  |
| -b     | Backup; create a backup of overwritten files                                     |
| -S     | Suffix; specify backup suffix (used with `-b`)                                   |
| -t     | Target; specify target directory first                                           |

- Moving Files
   - To move a file to a directory
```bash
mv file.txt Documents/
```

- To move and rename a file simultaneously:
```bash
mv file. txt Documents/new_name.txt
```

- Moving Directories
   - Directories are moved using the same syntax:
```bash
mv Source/ Destination/
```

- To rename a directory:
```bash
mv old_directory new_directory
```

> Note:
> - By default, `mv` overwrites existing files or directories without warning. Use caution to avoid data loss.
> - If the source is in the current directory, only the destination path is needed
> - If the source and destination are in different locations, both paths must be specified
> - Both absolute (`/home/user/Documents/`) and relative (`../Documents/`) paths work

**Cross Filesystem Operations**

   When moving files across different filesystems, `mv` automatically handles the operation by copying the file to the destination and then removing the original. This process is transparent to the user but may take longer than moves within the same filesystem.


**Default Aliases and Behavior**

Modern Linux distributions, including RHEL 8/9 and derivatives, typically set interactive aliases for safety:
   - **All users** (including root): Commonly have `alias mv='mv -i'` (interactive by default)
   - This is configured in `/etc/profile. d/colorls.sh` or individual shell configuration files

- Check current aliases:
```bash
alias mv
```

- Set a persistent alias in `~/.bashrc`:
```bash
alias mv='mv -i'
source ~/.bashrc
```

**Bypassing aliases when needed**:
```bash
\mv source destination           # Prefix with backslash
command mv source destination    # Use command builtin
mv -f source destination         # Use force option
```


**Examples**
- Create a Directory structure
  ```bash
  mkdir -p ~/dir2/{dir3/{dir6,dir7},dir4,dir5/dir8} \
&& touch ~/dir2/{file1,dir3/dir6/file2,dir3/dir6/file3,dir3/dir7/file4,dir3/dir7/file5,dir5/dir8/file6}
  ```
<img width="842" height="402" alt="Screenshot 2025-12-09 at 7 03 27 AM" src="https://github.com/user-attachments/assets/18cea4c4-aec5-40d9-9fe6-801edf8b7ad6" />


Example 1: Move `file2` from the current directory to `dir8`
```bash
mv ~/dir2/dir3/dir6/file2 ~/dir2/dir5/dir8/
```
<img width="795" height="348" alt="Screenshot 2025-12-09 at 7 06 17 AM" src="https://github.com/user-attachments/assets/1927e055-82d6-46b7-bedb-9b6e7cdcfb38" />

Example 2: Move `file4` from `dir7` to `dir8` and rename it with the new name `Project1`
```bash
mv ~/dir2/dir3/dir7/file4 ~/dir2/dir5/dir8/Project1
```
<img width="848" height="345" alt="Screenshot 2025-12-09 at 7 09 05 AM" src="https://github.com/user-attachments/assets/102c85c2-6973-401e-a504-a43468a1cb77" />

Example 3: Rename `file3` with the new name `file5`
```bash
mv ~/dir2/dir3/dir6/file3 ~/dir2/dir3/dir6/file5
```
<img width="729" height="328" alt="Screenshot 2025-12-09 at 7 13 32 AM" src="https://github.com/user-attachments/assets/ff41c4f0-2e13-4608-b9e3-cdcc9adca50d" />

Example 4: Interactive Move with Overwrite Protection
```bash
mv -i ~/dir2/dir3/dir6/file5 ~/dir2/dir3/dir7                  # Prompts: "mv: overwrite 'destination_file'?"
```
<img width="846" height="368" alt="Screenshot 2025-12-09 at 7 15 49 AM" src="https://github.com/user-attachments/assets/3588566e-58b0-40a9-a26d-4c852cf80414" />


Example 5: Moving Multiple Files
```bash
cd dir2/dir5/dir8/
mv file6 Project1 ../../dir4
cd
```
<img width="892" height="667" alt="Screenshot 2025-12-09 at 7 22 19 AM" src="https://github.com/user-attachments/assets/ba26d392-7871-4b7f-bd3f-35afabe03869" />

Example 6: Safe Move (No Overwrite)
```bash
mv -n ~/dir2/dir3/dir6/file5 ~/dir2/dir3/dir7            # Will not overwrite if file already exists at destination
```

Example 7: Moving a directory
```bash
mv ~/dir2/dir3/dir7 ~/dir2/dir5/dir8/
```
<img width="797" height="353" alt="Screenshot 2025-12-09 at 7 39 48 AM" src="https://github.com/user-attachments/assets/439ce444-975d-4070-af30-f8b36536e82c" />

---

**Considerations**

1. **File vs. Directory Behavior**:
   - If the destination is an existing directory, the source moves into it
   - If the destination doesn't exist, the source is renamed to that name
   - You cannot have a file and a directory with the same name in the same location

2. **Permissions**: You need write permission in both source and destination directories

---

## Copying Files and Directories

   - The `cp` Command
      - The `cp` command creates copies of files and directories.
      - Basic Syntax
```bash
cp [options] <source> <destination>
cp [options] <source1> <source2> ... <target_directory>
```

| Option                            | Description                                                                                          |
| ---------------------------------- | ---------------------------------------------------------------------------------------------------- |
| -i                                | Interactive; prompt before overwriting                                                               |
| -f                                | Force; overwrite without prompting                                                                   |
| -n, --no-clobber                  | Do not overwrite existing files                                                                      |
| -v                                | Verbose; show what’s being copied                                                                    |
| -u, --update                      | Copy only if source is newer than destination or destination is missing                              |
| -b                                | Backup; creates backups of files that would be overwritten                                           |
| -S, --suffix                      | Specify backup suffix (used with -b)                                                                 |
| -t, --target-directory            | Specify target directory first                                                                       |
| -r, -R, --recursive               | Copy directories recursively                                                                         |
| -a, --archive                     | Archive mode: preserves attributes, follows symlinks, recursive (equivalent to -dR --preserve=all)  |
| -p, --preserve                    | Preserve attributes (mode, ownership, timestamps)                                                    |
| -l, --link                        | Create hard links instead of copying                                                                 |
| -s, --symbolic-link               | Create symbolic links instead of copying                                                             |
| -P, --parents                     | Preserve directory structure; copy with full path                                                    |
| --backup                          | Make backups with version control style                                                              |
| -x, --one-file-system             | Stay on the current filesystem (don’t cross mount points)                                            |
| -T, --no-target-directory         | Treat destination as a normal file, not a directory                                                  |

- Copying Files
```bash
cp file.txt Documents/
cp file.txt Documents/new_name.txt
```

- Copying Directories
   - Use the `-r` (recursive) flag for directories:
```bash
cp -r source_directory/ destination_directory/
```

- To copy and rename a directory:
```bash
cp -r old_directory/ new_directory
```

**Examples**

```bash
mkdir -p software/{development,support,training}   && touch software/development/file1   software/support/file2   software/training/file3
```
<img width="795" height="334" alt="Screenshot 2025-12-09 at 8 28 42 AM" src="https://github.com/user-attachments/assets/b1947c0a-d68e-4a17-86bd-9931ae8337d2" />

Example 1: Copy a file
```bash
cp ~/software/development/file1 ~/software/support/
```
<img width="658" height="222" alt="Screenshot 2025-12-09 at 8 50 59 AM" src="https://github.com/user-attachments/assets/d5779770-ac6e-411e-94c2-f1ee30295bfe" />

Example 2: Copy and Rename
```bash
cp ~/software/development/file1 ~/software/training/copiedfile1
```
<img width="798" height="220" alt="Screenshot 2025-12-09 at 8 52 32 AM" src="https://github.com/user-attachments/assets/d4247613-fec6-4f7b-be6c-6ff2c8f73e0d" />

Example 3: Interactive Directory Copy with Attribute Preservation
```bash
 cp -rip ~/software/training/ ~/software/support/
```
<img width="765" height="588" alt="Screenshot 2025-12-09 at 9 00 16 AM" src="https://github.com/user-attachments/assets/d75a12d0-c8ae-4d9f-ab68-a45925f466bc" />


Example 4: Archive Copy (Complete Preservation)
```bash
cp -a ~/software/training/ ~/software/development/
```
>Note: Archive mode, which preserves metadata.

- Default Aliases for `cp`
   - Similar to `mv`, modern RHEL systems typically alias `cp` to `cp -i` for all users.  
- Configure in `~/.bashrc`:
```bash
alias cp='cp -i'
```

---
## Removing Files and Directories

- The `rm` Command
   - The `rm` command removes files and directories. 

- Basic Syntax
```bash
rm [options] <file_or_directory>
```

| Option                 | Description                                        |
| ---------------------- | -------------------------------------------------- |
| -i                 | Prompt before each deletion                        |
| -I                | Prompt once for large/recursive deletes            |
| -f               | Force delete, no prompts                           |
| -r / -R           | Delete directories recursively                     |
| -v                 | Show files as they’re deleted                      |
| --preserve-root    | Prevent deleting `/` (default behavior)            |
| --no-preserve-root | Allow deleting `/` (dangerous)                     |
| --interactive      | Control prompting mode (`never`, `once`, `always`) |
| **--one-file-system  | Don’t cross filesystem boundaries                  |


**Examples**

- Example 1: Removing Files
```bash
rm file1
rm -i file2              # Interactive removal
rm file{1.. 10}           # Remove multiple files
```

- Example 2: Removing Directories
```bash
rm -r directory/         # Remove directory and contents
rm -ri directory/        # Interactive directory removal
rm -rf directory/        # Force removal without prompts
```

- Example 3: Bulk Operations with Less Intrusive Prompting
```bash
rm -I *.log             # Prompts once before removing all . log files
rm -rI old_backups/     # Prompts once before removing directory recursively
```

- The `rmdir` Command
   - For removing **empty** directories only:
```bash
rmdir empty_directory/
rmdir -p path/to/empty/nested/dirs/  # Remove nested empty directories
```

- Default Aliases for `rm`

Modern RHEL typically sets `alias rm='rm -i'` for safety. This can be bypassed when needed:
```bash
\rm file               # Bypass alias
rm -f file             # Force without prompts
```

**Considerations**
   1. No Undo: Linux command-line deletions are permanent (no trash/recycle bin)
   2. Double check Paths: Verify current directory and paths before deleting
   3. Use Interactive Mode: For critical operations, use `-i` or `-I` option
   4. Wildcard Caution: Be extremely careful with wildcards in `rm` commands
   5. Test First: Use `ls` with the same pattern to see what would be affected

---

**Using Wildcards**
   - Wildcards expand to match multiple files, useful with all file operations. 

- Common Wildcards
   - `*` : Matches any string of characters
   - `?` : Matches any single character
   - `[abc]` : Matches any character in the set
   - `[a-z]` : Matches any character in the range
   - `{1.. 10}` : Expands to a sequence (1, 2, 3, ..., 10)
   - `{txt,log,conf}` : Matches any of the specified extensions


**Examples**
- Basic File Creation
```bash
touch filename.txt                 # Creates empty file or updates timestamp
touch file{1..10}.txt              # Creates multiple files (file1.txt to file10.txt)
touch document.{txt,md,pdf}        # Creates multiple files with different extensions
```

- Advanced `touch` Options
```bash
touch -t 202412080800.00 file.txt  # Set specific timestamp (YYYYMMDDhhmm. ss)
touch -d "2024-12-08 08:00:00" file. txt  # Set timestamp using date string
touch -c filename.txt              # Don't create file if it doesn't exist
touch -a filename.txt              # Update only access time
touch -m filename.txt              # Update only modification time
```

- Practical Examples
```bash
# Create a series of numbered files
touch report{01..12}.txt           # Creates report01.txt through report12.txt
touch {meeting,project,task}_notes.md  # Creates multiple note files

# Create files with the current date
touch "backup_$(date +%Y%m%d).txt"

# Create temporary files
touch /tmp/temp_{a..z}.log         # Creates temp_a.log through temp_z.log
```

- Creating Directories with `mkdir`

- Basic Directory Creation
```bash
mkdir directory_name               # Creates a single directory
mkdir dir1 dir2 dir3              # Creates multiple directories
mkdir -p parent/child/grandchild   # Creates nested directory structure (parents as needed)
```

- Advanced `mkdir` Options
```bash
mkdir -m 755 new_directory         # Creates directory with specific permissions
mkdir -m 700 private_folder        # Creates directory with restricted permissions
mkdir -v new_folder                # Verbose output (shows what's being created)
mkdir -p -m 644 path/to/dir        # Combine options:  create parents + set permissions
```

- Practical Examples
```bash
# Create project structure
mkdir -p ~/projects/{frontend,backend,database,docs}

# Create date-based directories
mkdir -p ~/logs/$(date +%Y)/$(date +%m)/$(date +%d)

# Create numbered directories
mkdir dir{001..100}                # Creates dir001 through dir100

# Create development environment structure
mkdir -p ~/workspace/{src,tests,docs,config}

# Create backup structure with permissions
mkdir -p -m 700 ~/backups/{daily,weekly,monthly}
```


- Project Setup Workflow
```bash
# Create main project structure
mkdir -p ~/myproject/{src,tests,docs,config,logs}

# Create source code subdirectories
mkdir -p ~/myproject/src/{components,utils,styles}

# Create initial files
touch ~/myproject/{README. md,package.json,. gitignore}
touch ~/myproject/src/{index.js,app.js,main.css}
touch ~/myproject/tests/{unit,integration,e2e}/{test1.. 5}.js

# Set appropriate permissions
chmod 755 ~/myproject/src
chmod 644 ~/myproject/src/*. js
```

- Data Organization Workflow
```bash
# Copy all configuration files from /etc to backup
mkdir -p ~/backup/configs
sudo cp /etc/*.conf ~/backup/configs/
ls backup/configs/


# Move files starting with 'm'
mkdir -p ~/important
mv ~/backup/configs/m* ~/important/


# Move files where the third character is 's'
mv ~/backup/configs/??s* ~/important/

# Remove files starting with 'p' (safely with interactive mode)
 rm -i ~/backup/configs/p*

# Create organised software directories
mkdir -p ~/software/{development,operation,support}

# Create numbered files for processing
touch ~/file{1..25}.txt

# Move files 1 through 15 to development
mv ~/file{1..15}.txt ~/software/development/
```

---

## Warnings

   1. Root Privileges: Use `sudo` only when necessary and understand the implications
   2. Wildcard Dangers: `rm -rf *` can delete everything in the current directory
   3. No Trash Recovery: Command-line deletions bypass desktop trash/recycle bins
   4. Cross Filesystem Performance: Operations across filesystems are slower
   5. Write Protected Files: `rm -f` will remove write protected files without warning

---
